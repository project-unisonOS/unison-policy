# P2.3: Policy Bundle Hot-Reload - Implementation Plan

**Date**: November 7, 2025  
**Status**: Planning  
**Estimated Time**: 3-4 days

---

## ðŸŽ¯ Objective

Implement atomic hot-reload of policy bundles without dropping requests, completing in < 100ms, with automatic rollback on validation failure.

---

## ðŸ“Š Current State Analysis

### What Already Exists âœ…

**File**: `unison-policy/src/server.py`

1. âœ… **Bundle Loading** (`load_bundle()`)
   - Loads signed bundles from disk
   - Verifies signatures
   - Extracts policies

2. âœ… **Bundle Signer** (`PolicyBundleSigner`)
   - Signs bundles
   - Verifies signatures
   - Handles bundle format

3. âœ… **Policy Storage** (`_RULES`, `_CURRENT_BUNDLE`)
   - In-memory policy storage
   - Global variables for current state

4. âœ… **Metrics** (`/metrics` endpoint)
   - Basic Prometheus metrics
   - Uptime tracking
   - Rule count

### What's Missing âŒ

1. âŒ **Bundle Versioning**
   - No version tracking
   - No version in responses

2. âŒ **Hot-Reload Mechanism**
   - No reload endpoint
   - No atomic swap
   - No file watching

3. âŒ **Rollback on Failure**
   - No validation before swap
   - No rollback mechanism

4. âŒ **Hot-Reload Metrics**
   - No reload timing
   - No reload success/failure tracking

5. âŒ **Tests**
   - No hot-reload tests

---

## ðŸ—ï¸ Implementation Plan

### Phase 1: Bundle Versioning (2-3 hours)

**Goal**: Add version tracking to bundles and responses

**Tasks**:

1. **Update Bundle Format**
   - Add `version` field to bundle metadata
   - Add `loaded_at` timestamp
   - Add `bundle_hash` for integrity

2. **Track Current Version**
   - Add `_CURRENT_VERSION` global
   - Update on bundle load
   - Include in metrics

3. **Include Version in Responses**
   - Add `policy_version` to `/decide` responses
   - Add `policy_version` to `/rules` responses
   - Add version info to `/metrics`

**Files to Modify**:
- `src/server.py` - Add version tracking
- `src/bundle_signer.py` - Add version to bundle format

**Acceptance Criteria**:
- [x] Bundles have version field
- [x] Responses include policy_version
- [x] Metrics show current version

---

### Phase 2: Hot-Reload Mechanism (4-5 hours)

**Goal**: Implement atomic bundle reload without dropping requests

**Tasks**:

1. **Create Reload Endpoint**
   - `POST /reload` - Trigger manual reload
   - `POST /reload/bundle` - Load specific bundle
   - Authentication required

2. **Implement Atomic Swap**
   - Load new bundle in memory
   - Validate bundle completely
   - Atomic swap with threading.Lock
   - Rollback on validation failure

3. **Add File Watching (Optional)**
   - Watch bundle file for changes
   - Auto-reload on modification
   - Debounce rapid changes

4. **Validation Before Swap**
   - Verify bundle signature
   - Validate policy format
   - Check for required fields
   - Ensure non-empty policies

**Files to Create/Modify**:
- `src/server.py` - Add reload endpoints
- `src/hot_reload.py` - Hot-reload logic
- `src/bundle_validator.py` - Validation logic

**Acceptance Criteria**:
- [x] Reload completes < 100ms
- [x] No requests dropped during reload
- [x] Invalid bundles rejected
- [x] Rollback works on failure

---

### Phase 3: Monitoring & Metrics (2-3 hours)

**Goal**: Add comprehensive monitoring for hot-reload operations

**Tasks**:

1. **Reload Metrics**
   - `unison_policy_reload_total` - Total reload attempts
   - `unison_policy_reload_success_total` - Successful reloads
   - `unison_policy_reload_failure_total` - Failed reloads
   - `unison_policy_reload_duration_seconds` - Reload duration
   - `unison_policy_bundle_version` - Current bundle version

2. **Reload History**
   - Track last 10 reload attempts
   - Include timestamp, version, success/failure
   - Expose via `/reload/history` endpoint

3. **Health Check Integration**
   - Include bundle version in `/readyz`
   - Warn if bundle is stale (> 24h old)

**Files to Modify**:
- `src/server.py` - Add metrics
- `src/hot_reload.py` - Track reload history

**Acceptance Criteria**:
- [x] All metrics exposed
- [x] Reload history available
- [x] Health check includes version

---

### Phase 4: Testing (3-4 hours)

**Goal**: Comprehensive test coverage for hot-reload

**Tests to Create**:

1. **Unit Tests** (15+ tests)
   - `test_bundle_versioning.py`
     - Test version extraction
     - Test version tracking
     - Test version in responses
   
   - `test_hot_reload.py`
     - Test successful reload
     - Test atomic swap
     - Test concurrent requests during reload
     - Test rollback on validation failure
     - Test reload timing (< 100ms)
   
   - `test_bundle_validation.py`
     - Test signature verification
     - Test policy format validation
     - Test empty bundle rejection
     - Test malformed bundle rejection

2. **Integration Tests** (5+ tests)
   - Test reload endpoint
   - Test concurrent policy decisions during reload
   - Test metrics after reload
   - Test reload history
   - Test file watching (if implemented)

**Files to Create**:
- `tests/test_bundle_versioning.py`
- `tests/test_hot_reload.py`
- `tests/test_bundle_validation.py`
- `tests/test_reload_integration.py`

**Acceptance Criteria**:
- [x] 15+ unit tests passing
- [x] 5+ integration tests passing
- [x] Coverage > 90%

---

### Phase 5: Documentation (1-2 hours)

**Goal**: Document hot-reload process and usage

**Documents to Create**:

1. **HOT_RELOAD.md**
   - How hot-reload works
   - Reload endpoint usage
   - Bundle versioning
   - Rollback behavior
   - Metrics and monitoring

2. **BUNDLE_FORMAT.md**
   - Bundle structure
   - Version field
   - Metadata requirements
   - Signature format

3. **API Documentation**
   - Update OpenAPI spec
   - Document `/reload` endpoints
   - Document version fields

**Files to Create/Modify**:
- `docs/HOT_RELOAD.md`
- `docs/BUNDLE_FORMAT.md`
- `README.md` - Add hot-reload section

**Acceptance Criteria**:
- [x] Hot-reload process documented
- [x] API endpoints documented
- [x] Examples provided

---

## ðŸ”§ Technical Design

### Bundle Version Format

```json
{
  "metadata": {
    "bundle_id": "policy-bundle-v1.2.3",
    "version": "1.2.3",
    "created_at": "2025-11-07T19:00:00Z",
    "bundle_hash": "sha256:abc123...",
    "signature": "..."
  },
  "policies": [...]
}
```

### Atomic Swap Implementation

```python
import threading

_RELOAD_LOCK = threading.Lock()
_CURRENT_BUNDLE = None
_CURRENT_VERSION = "0.0.0"
_RELOAD_HISTORY = []

def hot_reload_bundle(bundle_path: str) -> Dict[str, Any]:
    """
    Atomically reload policy bundle
    
    Returns:
        {
            "success": bool,
            "version": str,
            "duration_ms": float,
            "policies_loaded": int,
            "error": str | None
        }
    """
    start_time = time.time()
    
    try:
        # Load new bundle (outside lock)
        new_bundle = load_bundle(bundle_path)
        if not new_bundle:
            raise ValueError("Failed to load bundle")
        
        # Validate bundle (outside lock)
        validate_bundle(new_bundle)
        
        # Extract policies (outside lock)
        new_policies = load_policies_from_bundle(new_bundle)
        if not new_policies:
            raise ValueError("Bundle contains no policies")
        
        # Atomic swap (inside lock)
        with _RELOAD_LOCK:
            global _CURRENT_BUNDLE, _RULES, _CURRENT_VERSION
            
            # Save old state for rollback
            old_bundle = _CURRENT_BUNDLE
            old_rules = _RULES
            old_version = _CURRENT_VERSION
            
            try:
                # Swap to new state
                _CURRENT_BUNDLE = new_bundle
                _RULES = new_policies
                _CURRENT_VERSION = new_bundle["metadata"]["version"]
                
                duration_ms = (time.time() - start_time) * 1000
                
                # Record success
                _RELOAD_HISTORY.append({
                    "timestamp": datetime.now(timezone.utc).isoformat(),
                    "version": _CURRENT_VERSION,
                    "success": True,
                    "duration_ms": duration_ms,
                    "policies_loaded": len(_RULES)
                })
                
                logger.info(f"Hot-reload successful: v{_CURRENT_VERSION} ({duration_ms:.2f}ms)")
                
                return {
                    "success": True,
                    "version": _CURRENT_VERSION,
                    "duration_ms": duration_ms,
                    "policies_loaded": len(_RULES),
                    "error": None
                }
                
            except Exception as e:
                # Rollback on failure
                _CURRENT_BUNDLE = old_bundle
                _RULES = old_rules
                _CURRENT_VERSION = old_version
                raise
                
    except Exception as e:
        duration_ms = (time.time() - start_time) * 1000
        
        # Record failure
        _RELOAD_HISTORY.append({
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "version": None,
            "success": False,
            "duration_ms": duration_ms,
            "error": str(e)
        })
        
        logger.error(f"Hot-reload failed: {e} ({duration_ms:.2f}ms)")
        
        return {
            "success": False,
            "version": _CURRENT_VERSION,
            "duration_ms": duration_ms,
            "policies_loaded": 0,
            "error": str(e)
        }
```

### Reload Endpoint

```python
@app.post("/reload")
async def reload_bundle(request: Request):
    """Reload policy bundle from disk"""
    _metrics["/reload"] += 1
    
    # TODO: Add authentication
    
    result = hot_reload_bundle(BUNDLE_PATH)
    
    if result["success"]:
        return result
    else:
        raise HTTPException(status_code=500, detail=result["error"])
```

### Version in Responses

```python
@app.post("/decide")
def decide(request: Request, event: Dict[str, Any] = Body(...)):
    # ... existing logic ...
    
    return {
        "decision": decision,
        "policy_version": _CURRENT_VERSION,  # NEW
        "timestamp": datetime.now(timezone.utc).isoformat()
    }
```

---

## ðŸ“Š Success Metrics

| Metric | Target | How to Measure |
|--------|--------|----------------|
| **Reload Time** | < 100ms | `unison_policy_reload_duration_seconds` |
| **Zero Dropped Requests** | 0 | Test concurrent requests during reload |
| **Rollback Success** | 100% | Test invalid bundle rejection |
| **Test Coverage** | > 90% | pytest --cov |
| **Tests Passing** | 15+ | pytest count |

---

## ðŸš§ Implementation Order

1. âœ… **Phase 1**: Bundle Versioning (2-3 hours)
2. âœ… **Phase 2**: Hot-Reload Mechanism (4-5 hours)
3. âœ… **Phase 3**: Monitoring & Metrics (2-3 hours)
4. âœ… **Phase 4**: Testing (3-4 hours)
5. âœ… **Phase 5**: Documentation (1-2 hours)

**Total Estimated Time**: 12-17 hours (1.5-2 days)

---

## ðŸŽ¯ Acceptance Criteria Checklist

- [ ] Live bundle swap does not drop requests
- [ ] Reload completes < 100ms
- [ ] Responses include policy_version
- [ ] Rollback works on validation failure
- [ ] 15+ unit tests passing
- [ ] Metrics track reload operations
- [ ] Documentation complete

---

## ðŸ“ Notes

- Use threading.Lock for atomic swap
- Validate bundle before swapping
- Keep reload history (last 10)
- Add authentication to reload endpoint
- Consider file watching for auto-reload
- Ensure backward compatibility

---

**Status**: Ready to implement  
**Next Step**: Phase 1 - Bundle Versioning
